    1: import numpy as np
       
       # TODO: Add derivatives of potential w.r.t. all parameters
       
       ############################################################################
       # Pair potentials
       ############################################################################
       
    2: class PairPotential(object):
       
    1:     def __init__(self, atmi, atmj):
 4517:         self.atmi = atmi
 4517:         self.atmj = atmj
       
    1:     def describe(self):
               """interaction description"""
               return "{}:{:>12}{:>12}".format(self.prefix_label, self.atmi, self.atmj)
       
    1:     def set_epsilon(self, value):
               self.eps = value
       
    1:     def get_V_epsilons(self, r):
               """ Returns function V(epsilons)
       
               Default function for returning the Potential Energy as a
               function of epsilons. Since the majority of pairwise functions
               are scaled linearly with epsilon, this is a good default choice. This method can and should be overrided when necessary. See
       
               Parameters
               ----------
               r : array(float)
                   Distance for evaluating each pairwise potential function.
       
               Returns
               -------
               func : method
                   Function that computse the potential energy as a function
                   of epsilon
               """
       
               constants_list = self.dVdeps(r)
               def func(epsilon):
                   return constants_list * epsilon
       
               return func
       
    1:     def get_dV_depsilons(self, r):
               """ Returns function dV(epsilons)/depsilons
       
               Parameters
               ----------
               r : array(float)
                   Distance for evaluating each pairwise potential function.
       
               Returns
               -------
               func : method
                   Function that computse the derivative of the potential
                   energy with respect to epsilon, as a function of epsilon.
       
       
               """
       
               constants_list = self.dVdeps(r)
               def func(epsilon):
                   return constants_list
       
               return func
       
    1:     def __hash__(self):
               hash_value = hash(self.prefix_label)
               hash_value ^= hash(self.atmi)
               hash_value ^= hash(self.atmj)
               return hash_value
       
    1:     def _list_hash(self):
869556:         listhash = [hash(self.prefix_label)]
869556:         listhash.append(hash(self.atmi))
869556:         listhash.append(hash(self.atmj))
       
869556:         return listhash
       
    1:     def __eq__(self, other):
434778:         test = True
1739112:         for i,j in zip(self._list_hash(), other._list_hash()):
1304334:             test = test and (i==j)
       
434778:         return test
       
    1:     def __repr__(self):
               return "<PairPotential at 0x{}x>".format(id(self))
       
       
    2: class LJPotential(PairPotential):
       
    1:     def __init__(self, atmi, atmj, eps, r0):
  933:         PairPotential.__init__(self, atmi, atmj)
  933:         self.eps = eps
  933:         self.r0 = r0
  933:         self.other_params = [r0]
       
    2: class LJ12Potential(LJPotential):
       
    1:     def __init__(self, atmi, atmj, eps, r0):
  933:         LJPotential.__init__(self, atmi, atmj, eps, r0)
  933:         self.prefix_label = "LJ12"
       
    1:     def V(self, r):
520614:         return self.eps*self.dVdeps(r)
       
    1:     def dVdeps(self, r):
520614:         x = self.r0/r
520614:         return x**12
       
    1:     def dVdr(self, r):
               return self.eps*self.d2Vdrdeps(r)
       
    1:     def d2Vdrdeps(self, r):
               x = self.r0/r
               return (-12./self.r0)*(x**13)
       
    2: class LJ126Potential(LJPotential):
       
    1:     def __init__(self, atmi, atmj, eps, r0):
               LJPotential.__init__(self, atmi, atmj, eps, r0)
               self.prefix_label = "LJ126"
       
    1:     def V(self, r):
               return self.eps*self.dVdeps(r)
       
    1:     def dVdeps(self, r):
               x = self.r0/r
               return 4*((x**12) - (x**6))
       
    1:     def dVdr(self, r):
               return self.eps*self.d2Vdrdeps(r)
       
    1:     def d2Vdrdeps(self, r):
               x = self.r0/r
               return (-24/self.r0)*(2.*(x**13) - (x**7))
       
    2: class LJ1210Potential(LJPotential):
       
    1:     def __init__(self, atmi, atmj, eps, r0):
               LJPotential.__init__(self, atmi, atmj, eps, r0)
               self.prefix_label = "LJ1210"
       
    1:     def V(self, r):
               return self.eps*self.dVdeps(r)
       
    1:     def dVdeps(self, r):
               x = self.r0/r
               return 5.*(x**12) - 6.*(x**10)
       
    1:     def dVdr(self, r):
               return self.eps*self.d2Vdrdeps(r)
       
    1:     def d2Vdrdeps(self, r):
               x = self.r0/r
               return (-60./self.r0)*((x**13) - (x**11))
       
    2: class LJ1210RepPotential(LJPotential):
       
    1:     def __init__(self, atmi, atmj, eps, r0):
               LJPotential.__init__(self, atmi, atmj, eps, r0)
               self.prefix_label = "LJ1210REP"
       
    1:     def V(self, r):
               return self.eps*self.dVdeps(r)
       
    1:     def dVdeps(self, r):
               x = self.r0/r
               V = np.zeros(x.shape,float)
               V[x > 1] = 5.*(x[x > 1]**12) - 6.*(x[x > 1]**10) + 2.
               V[x <= 1] = -5.*(x[x <= 1]**12) - 6.*(x[x <= 1]**10)
               return V
       
    1:     def dVdr(self, r):
               return self.eps*self.d2Vdrdeps(r)
       
    1:     def d2Vdrdeps(self, r):
               x = self.r0/r
               V = np.zeros(x.shape,float)
               V[x > 1] = (-60./r0)*(x[x > 1]**13 - x[x > 1]**11)
               V[x <= 1] = (60./r0)*(x[x <= 1]**13 - x[x <= 1]**11)
               return V
       
    2: class TanhRepPotential(PairPotential):
       
    1:     def __init__(self, atmi, atmj, eps, r0, width):
               PairPotential.__init__(self, atmi, atmj)
               self.prefix_label = "TANHREP"
               self.eps = eps
               self.r0 = r0
               self.width = width
               self.other_params = [r0, width]
       
    1:     def V(self,r):
               return self.eps*self.dVdeps(r)
       
    1:     def dVdeps(self, r):
               alpha = 1./self.width
               r0prime = self.r0 + self.width
               return 0.5*(np.tanh(-alpha*(r - r0prime)) + 1.)
       
    1:     def dVdr(self, r):
               return self.eps*self.d2Vdrdeps(r)
       
    1:     def d2Vdrdeps(self, r):
               alpha = 1./self.width
               r0prime = self.r0 + self.width
               return -0.5*alpha*(1. - (np.tanh(-alpha*(r - r0prime)))**2)
       
    2: class LJ12TanhRepPotential(PairPotential):
       
    1:     def __init__(self, atmi, atmj, eps, rNC, r0, width):
  859:         PairPotential.__init__(self, atmi, atmj)
  859:         self.prefix_label = "LJ12TANHREP"
  859:         self.eps = eps
  859:         self.rNC = rNC
  859:         self.r0 = r0
  859:         self.width = width
  859:         self.other_params = [rNC, r0, width]
       
    1:     def V(self,r):
               return self.eps*self.dVdeps(r) + (self.rNC/r)**12
       
    1:     def dVdeps(self, r):
               alpha = 1./self.width
               r0prime = self.r0 + self.width
               return 0.5*(np.tanh(-alpha*(r - r0prime)) + 1.)
       
    1:     def dVdr(self, r):
               return self.eps*self.d2Vdrdeps(r) - (12./self.rNC)*((self.rNC/r)**13)
       
    1:     def d2Vdrdeps(self, r):
               alpha = 1./self.width
               r0prime = self.r0 + self.width
               return -0.5*alpha*(1. - (np.tanh(-alpha*(r - r0prime)))**2)
       
    2: class GaussianPotential(PairPotential):
       
    1:     def __init__(self, atmi, atmj, eps, r0, width):
  933:         PairPotential.__init__(self, atmi, atmj)
  933:         self.prefix_label = "GAUSSIAN"
  933:         self.eps = eps
  933:         self.r0 = r0
  933:         self.width = width
  933:         self.other_params = [r0, width]
       
    1:     def V(self, r):
               return self.eps*self.dVdeps(r)
       
    1:     def dVdeps(self, r):
520614:         return -np.exp(-((r - self.r0)**2)/(2.*(self.width**2)))
       
    1:     def dVdr(self, r):
               return self.eps*self.d2Vdrdeps(r)
       
    1:     def d2Vdrdeps(self, r):
               return ((r - self.r0)/(self.width**2))*np.exp(-((r - self.r0)**2)/(2.*(self.width**2)))
       
    2: class LJ12GaussianPotential(PairPotential):
       
    1:     def __init__(self, atmi, atmj, eps, rNC, r0, width):
  933:         PairPotential.__init__(self, atmi, atmj)
  933:         self.prefix_label = "LJ12GAUSSIAN"
  933:         self.eps = eps
  933:         self.rNC = rNC
  933:         self.r0 = r0
  933:         self.width = width
  933:         self.gaussian = GaussianPotential(atmi, atmj, self.eps, r0, width)
  933:         self.lj12 = LJ12Potential(atmi, atmj, 1.0, rNC)
  933:         self.other_params = [rNC, r0, width]
       
    1:     def V(self, r):
               return (1. + self.lj12.V(r))*(1. + self.gaussian.V(r)) - 1.
       
    1:     def dVdr(self, r):
               first = (1. + self.lj12.V(r))*self.gaussian.dVdr(r)
               second = (1. + self.gaussian.V(r))*self.lj12.dVdr(r)
               return first + second
       
    1:     def dVdeps(self, r):
520614:         return (1. + self.lj12.V(r))*self.gaussian.dVdeps(r)
       
    1:     def d2Vdrdeps(self, r):
               first = self.lj12.dVdr(r)*self.gaussian.dVdeps(r)
               second = (1. + self.lj12.V(r))*self.gaussian.d2Vdrdeps(r)
               return first + second
       
    1:     def set_epsilon(self, value):
   74:         self.eps = value
   74:         self.gaussian.eps = value
       
    2: class LJ12GaussTanhSwitching(PairPotential):
    1:     """ LJ12 Potential with Gaussian attractive and tanh repulsive"""
    1:     def __init__(self, atmi, atmj, eps, rNC, r0, width):
  859:         PairPotential.__init__(self, atmi, atmj)
  859:         self.prefix_label = "LJ12GAUSSIANTANH"
  859:         self.eps = eps
  859:         self.rNC = rNC
  859:         self.r0 = r0
  859:         self.width = width
  859:         self.attractive = LJ12GaussianPotential(atmi, atmj, np.abs(eps), rNC, r0, width)
  859:         self.repulsive = LJ12TanhRepPotential(atmi, atmj, np.abs(eps), rNC, r0, width)
  859:         self.determine_current()
  859:         self.other_params = [rNC, r0, width]
       
    1:     def V(self, r):
               return self.current.V(r)
       
    1:     def dVdr(self, r):
               return self.current.dVdr(r)
       
    1:     def dVdeps(self, r):
479322:         return self.current.dVdeps(r)
       
    1:     def d2Vdrdeps(self, r):
               return self.current.d2Vdrdeps(self, r)
       
    1:     def determine_current(self):
               """ If eps > 0, return attractive, otherwise return repulsive"""
 1718:         if self.eps < 0:
  473:             self.current = self.repulsive
               else:
 1245:             self.current = self.attractive
       
    1:     def set_epsilon(self, value):
  859:         self.eps = value
  859:         self.attractive.eps = np.abs(value)
  859:         self.repulsive.eps = np.abs(value)
  859:         self.determine_current()
       
    1:     def get_V_epsilons(self, r):
               constants_list_att = self.attractive.dVdeps(r)
               constants_list_rep = self.repulsive.dVdeps(r)
               def func(epsilon):
                   if epsilon < 0:
                       return constants_list_rep * epsilon
                   else:
                       return constants_list_att * epsilon
       
               return func
       
    1:     def get_dV_depsilons(self, r):
               constants_list_att = self.attractive.dVdeps(r)
               constants_list_rep = self.repulsive.dVdeps(r)
               constants_list_average = (constants_list_att + constants_list_rep) / 2.
               def func(epsilon):
                   if epsilon < 0:
                       return constants_list_rep
                   elif epsilon == 0:
                       return constants_list_average
                   else:
                       return constants_list_att
       
               return func
       
       
       
    2: class FlatBottomWell(PairPotential):
       
    1:     def __init__(self, atmi, atmj, kb, rNC, r0):
               PairPotential.__init__(self, atmi, atmj)
               self.prefix_label = "FLATWELL"
               self.kb = kb
               self.rNC = rNC
               self.r0 = r0
               self.other_params = [kb, rNC, r0]
       
    1:     def V(self, r):
               V = np.zeros(r.shape[0])
               V[r < self.r0] = (self.rNC/r[r < self.r0])**12
               V[r >= self.r0] = 0.5*self.kb*((r[r >= self.r0] - self.r0)**2)
               return V
       
    1:     def dVdr(self, r):
               dVdr = np.zeros(r.shape[0])
               dVdr[r < self.r0] = -(12./self.rNC)*((self.rNC/r[r < self.r0])**13)
               dVdr[r >= self.r0] = self.kb*(r[r >= self.r0] - self.r0)
               return dVdr
       
    2: class CustomPairPotential(PairPotential):
       
    1:     def __init__(self, atmi, atmj, func, *args):
               PairPotential.__init__(self, atmi, atmj)
               self.prefix_label = "CUSTOM"
               self.args = args
               self.func = func
       
    1:     def V(self, r):
               return self.func(r, *self.args)
       
    1:     def dVdr(self, r):
               return np.gradient(self.func(r, *self.args), r[1] - r[0])
       
    1: PAIR_POTENTIALS = {"LJ1210":LJ1210Potential,
    1:                 "GAUSSIAN":GaussianPotential,
    1:                 "LJ12GAUSSIAN":LJ12GaussianPotential,
    1:                 "TANHREP":TanhRepPotential,
    1:                 "LJ12TANHREP":LJ12TanhRepPotential,
    1:                 "CUSTOM":CustomPairPotential,
    1:                 "FLATWELL":FlatBottomWell,
    1:                 "LJ12GAUSSIANTANH":LJ12GaussTanhSwitching}
