    1: import numpy as np
       
    1: import mdtraj as md
       
    1: import util
       
    1: from hamiltonian import Hamiltonian
       
    2: class StructureBasedHamiltonian(Hamiltonian):
       
    1:     def __init__(self):
    1:         Hamiltonian.__init__(self)
       
    1:     def describe(self):
               pass
       
    1:     def add_sbm_backbone(self, Model):
       
    1:         if not hasattr(Model,"ref_traj"):
                   raise AttributeError("Need to set reference structure model.set_reference()")
       
               # How should user defined parameters be set? 
    1:         if self._default_parameters == {}:
    1:             util.default_sbm_parameters_warning()
    1:             self._use_sbm_default_parameters() 
       
    1:         if self._default_potentials == {}:
    1:             util.default_sbm_potentials_warning()
    1:             self._use_sbm_default_potentials() 
       
    1:         self._add_sbm_bonds(Model)
    1:         self._add_sbm_angles(Model)
    1:         self._add_sbm_dihedrals(Model)
       
    1:     def add_sbm_contacts(self, Model):
               self._add_sbm_contacts(Model)
       
    1:     def add_sbm_potentials(self, Model):
       
               self.add_sbm_backbone(Model)
               self.add_sbm_contacts(Model)
       
    1:     def _add_sbm_bonds(self, Model):
    1:         top = Model.mapping.top
       
    1:         if hasattr(Model,"ref_traj"):
    1:             kb = self._default_parameters["kb"]
    1:             code = self._default_potentials["bond"]
    1:             xyz = Model.ref_traj.xyz[0]
   66:             for atm1, atm2 in top.bonds:
   65:                 r0 = np.linalg.norm(xyz[atm1.index,:] - xyz[atm2.index,:])
   65:                 self._add_bond(code, atm1, atm2, kb, r0)
               else:
                   util.missing_reference_warning()
       
    1:     def _add_sbm_angles(self, Model):
    1:         structure = Model.mapping
       
    1:         if hasattr(Model,"ref_traj"):
    1:             ka = self._default_parameters["ka"]
    1:             code = self._default_potentials["angle"]
   96:             for atm1, atm2, atm3 in structure._angles:
   95:                 idxs = np.array([[atm1.index, atm2.index, atm3.index]])
   95:                 theta0 = md.compute_angles(Model.ref_traj, idxs)[0][0]
   95:                 self._add_angle(code, atm1, atm2, atm3, ka, theta0)
               else:
                   util.missing_reference_warning()
       
    1:     def _add_sbm_dihedrals(self, Model):
    1:         structure = Model.mapping
       
    1:         if hasattr(Model,"ref_traj"):
    1:             kd = self._default_parameters["kd"]
    1:             code = self._default_potentials["dihedral"]
   33:             for atm1, atm2, atm3, atm4 in structure._dihedrals:
   32:                 idxs = np.array([[atm1.index, atm2.index, atm3.index, atm4.index]])
   32:                 phi0 = md.compute_dihedrals(Model.ref_traj, idxs)[0][0]
       
                       #if temp_phi > 0:
                       #    phi0 = 2.*np.pi - temp_phi
                       #else:
                       #    phi0 = -temp_phi
       
   32:                 self._add_dihedral(code, atm1, atm2, atm3, atm4, kd, phi0, 1)
   32:                 self._add_dihedral(code, atm1, atm2, atm3, atm4, 0.5*kd, phi0, 3)
       
    1:             kd = self._default_parameters["ka"]
    1:             code = self._default_potentials["improper_dihedral"]
   32:             for atm1, atm2, atm3, atm4 in structure._improper_dihedrals:
                       # How does mdtraj angle correspond to gromacs? 
   31:                 idxs = np.array([[atm1.index, atm2.index, atm3.index, atm4.index]])
   31:                 phi0 = md.compute_dihedrals(Model.ref_traj, idxs)[0][0]
   31:                 self._add_dihedral(code, atm1, atm2, atm3, atm4, kd, phi0)
               else:
                   util.missing_reference_warning()
       
    1:     def _add_sbm_contacts(self, Model):
               """Add structure-based model contacts"""
           
               structure = Model.mapping
               if hasattr(Model,"ref_traj"):
                   eps = self._default_parameters["eps"]
                   code = self._default_potentials["contact"]
                   xyz = Model.ref_traj.xyz[0]
                   for atm1, atm2 in structure._contact_pairs:
                       r0 = np.linalg.norm(xyz[atm1.index,:] - xyz[atm2.index,:])
                       self._add_pair(code, atm1, atm2, eps, r0)
               else:
                   util.missing_reference_warning()
       
    1:     def _use_sbm_default_parameters(self):
    1:         self._default_parameters = {"kb":20000., # kJ/(mol nm^2)
    1:                                     "ka":40.,  # kJ/(mol deg^2)
    1:                                     "kd":1.,     # kJ/mol
    1:                                     "eps":1}     # kJ/(mol nm)
       
    1:     def _use_sbm_default_potentials(self):
    1:         self._default_potentials = {"bond":"HARMONIC_BOND",
    1:                                 "angle":"HARMONIC_ANGLE",
    1:                                 "dihedral":"COSINE_DIHEDRAL",
    1:                                 "improper_dihedral":"HARMONIC_DIHEDRAL",
    1:                                 "contact":"LJ1210"}
       
    1:     def calc_native_nonative_pair_energy(self, traj, n_native_pairs, sum=True):
               """Energy for pair interactions
       
               Parameters
               ----------
               traj : mdtraj.Trajectory
               
               sum : bool (opt.)
                   If sum=True return the total energy.
               """
               r = md.compute_distances(traj, self._pair_idxs)
               if sum:
                   Enat = np.zeros(traj.n_frames, float)
                   Enon = np.zeros(traj.n_frames, float)
               else:
                   Enat = np.zeros((traj.n_frames, n_native_pairs), float)
                   Enon = np.zeros((traj.n_frames, self.n_pairs - n_native_pairs), float)
       
               for i in range(n_native_pairs):
                   if sum:
                       Enat += self._pairs[i].V(r[:,i])
                   else:
                       Enat[:,i] = self._pairs[i].V(r[:,i])
       
               for i in range(n_native_pairs, self.n_pairs):
                   if sum:
                       Enon += self._pairs[i].V(r[:,i])
                   else:
                       Enon[:,i - n_native_pairs] = self._pairs[i].V(r[:,i])
               return Enat, Enon
       
